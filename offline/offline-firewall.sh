#!/usr/bin/env bash
# Offline firewall profile for macOS research systems
# Security: Tailscale-only access with controlled update windows
set -euo pipefail

BASE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PF_BASE="/etc/pf.offline.conf"
PF_VARS="/etc/pf.offline.vars"
PF_UPDATES="/etc/pf.offline-updates.conf"

usage() {
  cat <<'USAGE'
Usage: offline-firewall.sh [flags] <command> [args]

Commands:
  enable            Install/enable offline pf rules
  open-updates [s]  Open update window for N seconds (default 900)
  close-updates     Close update window immediately
  sync-tables       Refresh pf tables (LM Studio/HF + Tailscale DERP)
  status            Show pf status and matching rules
  audit             Run post-update security audit

Flags (optional overrides):
  --ts-if <if>      Tailscale utun interface
  --wan-if <if>     Primary WAN interface (en0/en1)
  --ts-cidr <cidr>  This host's Tailscale address (e.g. 100.80.10.5/32)

Defaults are auto-detected; pass overrides if detection is wrong.
USAGE
}

need_root() {
  if [[ $EUID -ne 0 ]]; then
    # Only preserve specific safe variables, not entire environment
    exec sudo TS_IF="$TS_IF" WAN_IF="$WAN_IF" TS_CIDR="$TS_CIDR" "$0" "$@"
  fi
}

detect_ts_if() {
  # Try tailscale CLI first (works on Linux and some macOS setups)
  local ts_cmd="tailscale"
  if ! command -v tailscale &>/dev/null; then
    ts_cmd="/Applications/Tailscale.app/Contents/MacOS/Tailscale"
  fi

  local tun
  tun=$("$ts_cmd" status --json 2>/dev/null | python3 -c "
import json,sys
try:
    data=json.load(sys.stdin)
    tun=data.get('Self',{}).get('TunName')
    if tun:
        print(tun)
except Exception:
    pass
" 2>/dev/null)

  if [[ -n "$tun" ]]; then
    echo "$tun"
    return
  fi

  # Fallback for macOS system extension: find utun with 100.x.x.x IP
  ifconfig 2>/dev/null | awk '
    /^utun[0-9]+:/ { iface=$1; sub(/:$/, "", iface) }
    /inet 100\./ { print iface; exit }
  '
}

detect_ts_cidr() {
  local ts_cmd="tailscale"
  if ! command -v tailscale &>/dev/null; then
    ts_cmd="/Applications/Tailscale.app/Contents/MacOS/Tailscale"
  fi

  local cidr
  cidr=$("$ts_cmd" status --json 2>/dev/null | python3 -c "
import json,sys
try:
    data=json.load(sys.stdin)
    addrs=data.get('Self',{}).get('TailscaleIPs') or data.get('Self',{}).get('Addresses') or []
    for a in addrs:
        if a.startswith('100.'):
            ip = a.split('/')[0]
            print(f'{ip}/32')
            break
except Exception:
    pass
" 2>/dev/null)

  if [[ -n "$cidr" ]]; then
    echo "$cidr"
    return
  fi

  # Fallback: get IP from the Tailscale utun interface
  local ts_if
  ts_if=$(detect_ts_if)
  if [[ -n "$ts_if" ]]; then
    ifconfig "$ts_if" 2>/dev/null | awk '/inet 100\./ { print $2"/32"; exit }'
  fi
}

detect_wan_if() {
  route -n get default 2>/dev/null | awk '/interface:/{print $2; exit}'
}

parse_flags() {
  TS_IF=${TS_IF:-""}
  WAN_IF=${WAN_IF:-""}
  TS_CIDR=${TS_CIDR:-""}
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --ts-if) TS_IF="$2"; shift 2 ;;
      --wan-if) WAN_IF="$2"; shift 2 ;;
      --ts-cidr) TS_CIDR="$2"; shift 2 ;;
      --help|-h) usage; exit 0 ;;
      *) CMD="$1"; shift; CMD_ARGS=("$@"); break ;;
    esac
  done
}

write_vars() {
  cat > "$PF_VARS" <<EOFV
# Generated by offline-firewall.sh
# macOS pf macro overrides
TS_IF_PLACEHOLDER
EOFV
}

# We'll replace placeholders in-place to keep heredoc readable
render_vars() {
  local ts_if=${TS_IF:-$(detect_ts_if)}
  local wan_if=${WAN_IF:-$(detect_wan_if)}
  local ts_cidr=${TS_CIDR:-$(detect_ts_cidr)}

  [[ -n "$ts_if" ]] || { echo "✗ Could not detect Tailscale interface; pass --ts-if" >&2; exit 1; }
  [[ -n "$wan_if" ]] || { echo "✗ Could not detect WAN interface; pass --wan-if" >&2; exit 1; }
  [[ -n "$ts_cidr" ]] || { echo "✗ Could not detect Tailscale address; pass --ts-cidr" >&2; exit 1; }

  write_vars
  sed -i '' "s|TS_IF_PLACEHOLDER|ts_if = $ts_if\nwan_if = $wan_if\nts_cidr = $ts_cidr|" "$PF_VARS"
}

verify_script_integrity() {
  local script="$1"
  local checksum_file="$BASE_DIR/checksums.sha256"

  if [[ ! -f "$checksum_file" ]]; then
    echo "⚠️  Warning: No checksum file found at $checksum_file" >&2
    echo "   Generate with: cd $BASE_DIR && shasum -a 256 *.sh *.conf > checksums.sha256" >&2
    return 0  # Allow install but warn
  fi

  local filename=$(basename "$script")
  local expected=$(grep "$filename" "$checksum_file" | awk '{print $1}')

  if [[ -z "$expected" ]]; then
    echo "⚠️  Warning: No checksum found for $filename" >&2
    return 0
  fi

  local actual=$(shasum -a 256 "$script" | awk '{print $1}')

  if [[ "$expected" != "$actual" ]]; then
    echo "✗ ERROR: Checksum mismatch for $filename" >&2
    echo "  Expected: $expected" >&2
    echo "  Actual:   $actual" >&2
    echo "  This could indicate file tampering!" >&2
    return 1
  fi

  return 0
}

install_files() {
  # Verify script integrity before installing
  verify_script_integrity "$BASE_DIR/sync-pf-tables.sh" || exit 1
  verify_script_integrity "$BASE_DIR/pf.offline.conf" || exit 1
  verify_script_integrity "$BASE_DIR/pf.offline-updates.conf" || exit 1

  [[ -f "$PF_BASE" ]] || cp "$BASE_DIR/pf.offline.conf" "$PF_BASE"
  [[ -f "$PF_UPDATES" ]] || cp "$BASE_DIR/pf.offline-updates.conf" "$PF_UPDATES"
  cp "$BASE_DIR/sync-pf-tables.sh" /usr/local/bin/sync-pf-tables.sh
  chmod +x /usr/local/bin/sync-pf-tables.sh
}

cmd_enable() {
  need_root "$@"
  render_vars
  install_files
  cp "$BASE_DIR/pf.offline.conf" "$PF_BASE"
  cp "$BASE_DIR/pf.offline-updates.conf" "$PF_UPDATES"

  # Validate syntax before loading
  echo "Validating pf.conf syntax..."
  if ! pfctl -nf "$PF_BASE" 2>/dev/null; then
    echo "✗ ERROR: pf.conf syntax validation failed" >&2
    exit 1
  fi
  echo "✓ Syntax validation passed"

  pfctl -a offline-updates -F rules 2>/dev/null || true
  pfctl -f "$PF_BASE" 2>/dev/null
  pfctl -E 2>/dev/null || pfctl -e 2>/dev/null

  logger -t offline-firewall "Offline profile enabled"

  echo ""
  echo "✓ pf offline profile loaded successfully"
  echo "  ts_if=$(grep ts_if "$PF_VARS" | awk '{print $3}' | tr -d '"')"
  echo "  wan_if=$(grep wan_if "$PF_VARS" | awk '{print $3}' | tr -d '"')"
  echo "  ts_cidr=$(grep ts_cidr "$PF_VARS" | awk '{print $3}' | tr -d '"')"
  echo ""
  echo "⚠️  IMPORTANT: pf must be re-enabled on each reboot"
  echo "   Consider installing the launch daemon:"
  echo "   sudo cp $BASE_DIR/com.offline.pf.plist /Library/LaunchDaemons/"
  echo "   sudo launchctl load /Library/LaunchDaemons/com.offline.pf.plist"
}

cmd_open_updates() {
  need_root "$@"
  local dur=${1:-900}

  # Validate update rules syntax before loading
  if ! pfctl -nf "$PF_UPDATES" 2>/dev/null; then
    echo "✗ ERROR: update rules syntax validation failed" >&2
    exit 1
  fi

  pfctl -a offline-updates -f "$PF_UPDATES"

  # Populate the tables with resolved IPs
  echo "Syncing update tables..."
  /usr/local/bin/sync-pf-tables.sh || echo "⚠️  Warning: Failed to sync tables, update hosts may not be reachable" >&2

  logger -t offline-firewall "Update window opened for ${dur}s"

  if [[ $dur -gt 0 ]]; then
    ( sleep "$dur"; pfctl -a offline-updates -F rules; logger -t offline-firewall "Update window auto-closed after ${dur}s" ) &
    local pid=$!
    echo "✓ Update window opened for ${dur}s"
    echo "  Auto-close PID: $pid"
    echo "  To close early: sudo $0 close-updates"
    echo "  To cancel auto-close: sudo kill $pid"
    echo ""
    echo "Allowed domains during update window:"
    echo "  - GitHub (api, raw, objects, ghcr.io)"
    echo "  - Homebrew (formulae.brew.sh)"
    echo "  - LM Studio (lmstudio.ai)"
    echo "  - Hugging Face (huggingface.co, cdn-lfs, xethub)"
    echo "  - Python (pypi.org, pythonhosted.org)"
    echo "  - Rust (crates.io)"
    echo "  - Go (golang.org, proxy.golang.org)"
  else
    echo "✓ Update window opened (no auto-close)"
    echo "  Close manually with: sudo $0 close-updates"
  fi
}

cmd_close_updates() {
  need_root "$@"
  pfctl -a offline-updates -F rules
  logger -t offline-firewall "Update window closed manually"
  echo "✓ Update window closed"
}

cmd_status() {
  echo "=== PF Status ==="
  pfctl -s info
  echo ""
  echo "=== Active Rules (first 40) ==="
  pfctl -sr | head -n 40
  echo ""
  echo "=== Update Window Status ==="
  if pfctl -a offline-updates -sr 2>/dev/null | grep -q .; then
    echo "✓ Update window is OPEN"
    echo ""
    pfctl -a offline-updates -sr
  else
    echo "✗ Update window is CLOSED"
  fi
  echo ""
  echo "=== PF Tables ==="
  echo "tailscale_hosts:"
  pfctl -t tailscale_hosts -T show 2>/dev/null | head -n 10 || echo "  (empty or not loaded)"
}

cmd_sync_tables() {
  "$BASE_DIR/sync-pf-tables.sh"
}

cmd_audit() {
  "$BASE_DIR/audit-after-update.sh"
}

main() {
  if [[ $# -lt 1 ]]; then
    usage; exit 1
  fi
  parse_flags "$@"
  case "${CMD:-}" in
    enable) cmd_enable "${CMD_ARGS[@]:-}" ;;
    open-updates) cmd_open_updates ${CMD_ARGS[0]:-} ;;
    close-updates) cmd_close_updates ;;
    status) cmd_status ;;
    sync-tables) cmd_sync_tables ;;
    audit) cmd_audit ;;
    *) usage; exit 1 ;;
  esac
}

main "$@"
